# Omikuji
"Modular HTML5 Audio Engine &amp; DAW with custom DSP injection and total session serialization."
OMIKUJI // MASTER_CORE_v18Ultra-Stable HTML5 DAW & Step SequencerOMIKUJI is a high-performance, browser-based digital audio workstation designed for rapid beat construction and live performance. Built on the Web Audio API, it features a unique "Bank" system for pattern management, an external JS-injection architecture for custom machines (FX), and a core engine stress-tested for zero-latency rhythmic precision.ðŸš€ Key FeaturesSWING_FIX Core: A precision-timing engine that supports external .js swing modules for custom groove templates.8-Pattern Bank System: Switch between 8 independent patterns on the fly or use the SONG_MODE block arranger for full compositions.Modular FX Injector: Load external JavaScript "Machines" (plugins) directly into the signal chain.Integrated Recorder: ARM and capture your master output directly to high-quality .wav files.Session Portability: Export entire projects (including samples and FX state) as a single .omikuji (ZIP) file.ðŸ›  Documentation1. The Engine CoreThe sequencer operates on a 16th-note grid ($60 / BPM / 4$).Mono-Trigger Logic: Every track is forced to mono-trigger, ensuring samples never overlap and muddy the mixâ€”essential for clean, lo-fi, and hip-hop production.Swing Offset: Calculated using the formula:$$Time_{final} = NextStep + (SwingOffset \times SecPerStep)$$2. User Interface GuideComponentFunctionBLOCK_ARRANGERDefine the play order of your 8 patterns for Song Mode.PIANO DRAWERExpand any track to access a full melodic grid with octave control.VELOCITY BOXVertical sliders below each step to control individual note dynamics.INJECT MACHINEFound in the FX tab; allows for dynamic loading of custom JS DSP code.3. Workflow InstructionsLoading Samples: Click + TRACK, then use the LOAD button to import any audio file.Sequencing: Click the grid for triggers; drag the velocity bars to add "human feel."Applying FX: Switch to the FX Tab, inject a machine, then return to the SEQ Tab and change the ROUTE dropdown on your track from MASTER to your new FX ID.Recording: Press ARM REC, then START. Once you stop the transport, the EXPORT WAV button will appear.ðŸ— Developer / Technical SpecsLanguage: HTML5, CSS3 (NIN/DATA typography), Vanilla JavaScript.Libraries: JSZip (Session management).Audio Architecture: * AudioContext -> GainNode (Track) -> FX_Node (Optional) -> Master_Gain -> MediaStreamDestination.Swing Engine API: To write a custom swing module, export a default object with a getOffset(step, amount) function.

OMIKUJI // PLUGIN API SPECIFICATION (v18)Any .js file intended for injection must export a class that adheres to the following contract:1. The Constructor constructor(ctx)Input: The AudioContext from the Host.Required Properties:this.id: A string (assigned by Host during injection).this.name: A display name for the UI.this.input: A WebAudioNode (e.g., GainNode) for incoming audio signals.this.output: A WebAudioNode for processed audio signals.2. Required MethodsMethodDescriptionrenderUI(container)Called by the Host to draw the plugin's controls. container is the HTML element provided by the Host.getState()Must return a JSON-serializable object containing all current parameter values (used for session saving).setState(state)Must accept a state object and update the internal parameters/UI accordingly.3. Optional MethodsnoteOn(frequency, time, velocity): If the plugin is an instrument (Synth) rather than an effect, the Host will call this method during sequencer playback.Observations on your current code:1. The "Note Trigger" StandardIn your sch() (scheduler) function, you have this logic:JavaScriptif(fx && typeof fx.noteOn === 'function') fx.noteOn(st.freq, time, st.v);
This is a "Hidden API." It means your Bit-Crusher doesn't need a noteOn, but if you build a Sub-Synth plugin, it must have that method or it will be silent. You should document this as the Instrument Extension.2. The UI Context BreakYour plugin uses this.closest('.fx-slot').plugin. This is a clever "DOM-traversal" hack to get back to the JavaScript object from the HTML. In your API documentation, you should note:"Plugins must attach a reference to themselves to their UI container via container.plugin = this to enable event-driven parameter updates."3. Performance NoteYour Bit-Crusher uses createScriptProcessor. As we discussed earlier, this runs on the main thread. Since you don't have C++ tools, this is fine for now! But if you start loading 10+ machines, you might notice the UI "stuttering."
